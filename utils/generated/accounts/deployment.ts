/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  Account,
  Context,
  Pda,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  assertAccountExists,
  deserializeAccount,
  gpaBuilder,
  publicKey as toPublicKey,
} from "@metaplex-foundation/umi";
import {
  Serializer,
  array,
  bool,
  mapSerializer,
  publicKey as publicKeySerializer,
  string,
  struct,
  u64,
  u8,
} from "@metaplex-foundation/umi/serializers";

export type Deployment = Account<DeploymentAccountData>;

export type DeploymentAccountData = {
  discriminator: Array<number>;
  creator: PublicKey;
  limitPerMint: bigint;
  maxNumberOfTokens: bigint;
  numberOfTokensIssued: bigint;
  decimals: number;
  useInscriptions: boolean;
  deploymentType: number;
  requireCreatorCosign: boolean;
  migratedFromLegacy: boolean;
  escrowNonFungibleCount: bigint;
  ticker: string;
  deploymentTemplate: string;
  mintTemplate: string;
  fungibleMint: PublicKey;
  offchainUrl: string;
  /**
   * when cosigner is active this can be toggled to disable swap cosigner
   * while still requiring cosigner for other actions such as join
   */
  disableSwapCosigner: boolean;
  padding: Array<number>;
};

export type DeploymentAccountDataArgs = {
  creator: PublicKey;
  limitPerMint: number | bigint;
  maxNumberOfTokens: number | bigint;
  numberOfTokensIssued: number | bigint;
  decimals: number;
  useInscriptions: boolean;
  deploymentType: number;
  requireCreatorCosign: boolean;
  migratedFromLegacy: boolean;
  escrowNonFungibleCount: number | bigint;
  ticker: string;
  deploymentTemplate: string;
  mintTemplate: string;
  fungibleMint: PublicKey;
  offchainUrl: string;
  /**
   * when cosigner is active this can be toggled to disable swap cosigner
   * while still requiring cosigner for other actions such as join
   */
  disableSwapCosigner: boolean;
  padding: Array<number>;
};

export function getDeploymentAccountDataSerializer(): Serializer<
  DeploymentAccountDataArgs,
  DeploymentAccountData
> {
  return mapSerializer<DeploymentAccountDataArgs, any, DeploymentAccountData>(
    struct<DeploymentAccountData>(
      [
        ["discriminator", array(u8(), { size: 8 })],
        ["creator", publicKeySerializer()],
        ["limitPerMint", u64()],
        ["maxNumberOfTokens", u64()],
        ["numberOfTokensIssued", u64()],
        ["decimals", u8()],
        ["useInscriptions", bool()],
        ["deploymentType", u8()],
        ["requireCreatorCosign", bool()],
        ["migratedFromLegacy", bool()],
        ["escrowNonFungibleCount", u64()],
        ["ticker", string()],
        ["deploymentTemplate", string()],
        ["mintTemplate", string()],
        ["fungibleMint", publicKeySerializer()],
        ["offchainUrl", string()],
        ["disableSwapCosigner", bool()],
        ["padding", array(u8(), { size: 199 })],
      ],
      { description: "DeploymentAccountData" },
    ),
    (value) => ({
      ...value,
      discriminator: [66, 90, 104, 89, 183, 130, 64, 178],
    }),
  ) as Serializer<DeploymentAccountDataArgs, DeploymentAccountData>;
}

export function deserializeDeployment(rawAccount: RpcAccount): Deployment {
  return deserializeAccount(rawAccount, getDeploymentAccountDataSerializer());
}

export async function fetchDeployment(
  context: Pick<Context, "rpc">,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions,
): Promise<Deployment> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options,
  );
  assertAccountExists(maybeAccount, "Deployment");
  return deserializeDeployment(maybeAccount);
}

export async function safeFetchDeployment(
  context: Pick<Context, "rpc">,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions,
): Promise<Deployment | null> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options,
  );
  return maybeAccount.exists ? deserializeDeployment(maybeAccount) : null;
}

export async function fetchAllDeployment(
  context: Pick<Context, "rpc">,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions,
): Promise<Deployment[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options,
  );
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, "Deployment");
    return deserializeDeployment(maybeAccount);
  });
}

export async function safeFetchAllDeployment(
  context: Pick<Context, "rpc">,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions,
): Promise<Deployment[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options,
  );
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) => deserializeDeployment(maybeAccount as RpcAccount));
}

export function getDeploymentGpaBuilder(
  context: Pick<Context, "rpc" | "programs">,
) {
  const programId = context.programs.getPublicKey(
    "libreplexFairLaunch",
    "8bvPnYE5Pvz2Z9dE6RAqWr1rzLknTndZ9hwvRE6kPDXP",
  );
  return gpaBuilder(context, programId)
    .registerFields<{
      discriminator: Array<number>;
      creator: PublicKey;
      limitPerMint: number | bigint;
      maxNumberOfTokens: number | bigint;
      numberOfTokensIssued: number | bigint;
      decimals: number;
      useInscriptions: boolean;
      deploymentType: number;
      requireCreatorCosign: boolean;
      migratedFromLegacy: boolean;
      escrowNonFungibleCount: number | bigint;
      ticker: string;
      deploymentTemplate: string;
      mintTemplate: string;
      fungibleMint: PublicKey;
      offchainUrl: string;
      disableSwapCosigner: boolean;
      padding: Array<number>;
    }>({
      discriminator: [0, array(u8(), { size: 8 })],
      creator: [8, publicKeySerializer()],
      limitPerMint: [40, u64()],
      maxNumberOfTokens: [48, u64()],
      numberOfTokensIssued: [56, u64()],
      decimals: [64, u8()],
      useInscriptions: [65, bool()],
      deploymentType: [66, u8()],
      requireCreatorCosign: [67, bool()],
      migratedFromLegacy: [68, bool()],
      escrowNonFungibleCount: [69, u64()],
      ticker: [77, string()],
      deploymentTemplate: [null, string()],
      mintTemplate: [null, string()],
      fungibleMint: [null, publicKeySerializer()],
      offchainUrl: [null, string()],
      disableSwapCosigner: [null, bool()],
      padding: [null, array(u8(), { size: 199 })],
    })
    .deserializeUsing<Deployment>((account) => deserializeDeployment(account))
    .whereField("discriminator", [66, 90, 104, 89, 183, 130, 64, 178]);
}
