/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  Account,
  Context,
  Option,
  OptionOrNullable,
  Pda,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  assertAccountExists,
  deserializeAccount,
  gpaBuilder,
  publicKey as toPublicKey,
} from "@metaplex-foundation/umi";
import {
  Serializer,
  array,
  bool,
  mapSerializer,
  option,
  publicKey as publicKeySerializer,
  struct,
  u16,
  u64,
  u8,
} from "@metaplex-foundation/umi/serializers";
import {
  MultiplierLimits,
  MultiplierLimitsArgs,
  getMultiplierLimitsSerializer,
} from "../types";

export type DeploymentConfig = Account<DeploymentConfigAccountData>;

export type DeploymentConfigAccountData = {
  discriminator: Array<number>;
  deployment: PublicKey;
  creatorFeeTreasury: PublicKey;
  creatorFeePerMintLamports: bigint;
  transferFeeInBasisPoints: number;
  cosignerProgramId: PublicKey;
  multiplierLimits: Option<MultiplierLimits>;
  transferFeeWithdrawAuthority: Option<PublicKey>;
  transferFeeTargetWallet: Option<PublicKey>;
  totalSplEquivalentMinted: bigint;
  splExcessInEscrow: bigint;
  /** used for variable-rate swaps */
  allowBurn: boolean;
  allowClaimTransferFeeAuthAsCreator: boolean;
  uncheckedFungible: boolean;
};

export type DeploymentConfigAccountDataArgs = {
  deployment: PublicKey;
  creatorFeeTreasury: PublicKey;
  creatorFeePerMintLamports: number | bigint;
  transferFeeInBasisPoints: number;
  cosignerProgramId: PublicKey;
  multiplierLimits: OptionOrNullable<MultiplierLimitsArgs>;
  transferFeeWithdrawAuthority: OptionOrNullable<PublicKey>;
  transferFeeTargetWallet: OptionOrNullable<PublicKey>;
  totalSplEquivalentMinted: number | bigint;
  splExcessInEscrow: number | bigint;
  /** used for variable-rate swaps */
  allowBurn: boolean;
  allowClaimTransferFeeAuthAsCreator: boolean;
  uncheckedFungible: boolean;
};

export function getDeploymentConfigAccountDataSerializer(): Serializer<
  DeploymentConfigAccountDataArgs,
  DeploymentConfigAccountData
> {
  return mapSerializer<
    DeploymentConfigAccountDataArgs,
    any,
    DeploymentConfigAccountData
  >(
    struct<DeploymentConfigAccountData>(
      [
        ["discriminator", array(u8(), { size: 8 })],
        ["deployment", publicKeySerializer()],
        ["creatorFeeTreasury", publicKeySerializer()],
        ["creatorFeePerMintLamports", u64()],
        ["transferFeeInBasisPoints", u16()],
        ["cosignerProgramId", publicKeySerializer()],
        ["multiplierLimits", option(getMultiplierLimitsSerializer())],
        ["transferFeeWithdrawAuthority", option(publicKeySerializer())],
        ["transferFeeTargetWallet", option(publicKeySerializer())],
        ["totalSplEquivalentMinted", u64()],
        ["splExcessInEscrow", u64()],
        ["allowBurn", bool()],
        ["allowClaimTransferFeeAuthAsCreator", bool()],
        ["uncheckedFungible", bool()],
      ],
      { description: "DeploymentConfigAccountData" },
    ),
    (value) => ({
      ...value,
      discriminator: [13, 112, 57, 81, 43, 26, 156, 18],
    }),
  ) as Serializer<DeploymentConfigAccountDataArgs, DeploymentConfigAccountData>;
}

export function deserializeDeploymentConfig(
  rawAccount: RpcAccount,
): DeploymentConfig {
  return deserializeAccount(
    rawAccount,
    getDeploymentConfigAccountDataSerializer(),
  );
}

export async function fetchDeploymentConfig(
  context: Pick<Context, "rpc">,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions,
): Promise<DeploymentConfig> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options,
  );
  assertAccountExists(maybeAccount, "DeploymentConfig");
  return deserializeDeploymentConfig(maybeAccount);
}

export async function safeFetchDeploymentConfig(
  context: Pick<Context, "rpc">,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions,
): Promise<DeploymentConfig | null> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options,
  );
  return maybeAccount.exists ? deserializeDeploymentConfig(maybeAccount) : null;
}

export async function fetchAllDeploymentConfig(
  context: Pick<Context, "rpc">,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions,
): Promise<DeploymentConfig[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options,
  );
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, "DeploymentConfig");
    return deserializeDeploymentConfig(maybeAccount);
  });
}

export async function safeFetchAllDeploymentConfig(
  context: Pick<Context, "rpc">,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions,
): Promise<DeploymentConfig[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options,
  );
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) =>
      deserializeDeploymentConfig(maybeAccount as RpcAccount),
    );
}

export function getDeploymentConfigGpaBuilder(
  context: Pick<Context, "rpc" | "programs">,
) {
  const programId = context.programs.getPublicKey(
    "libreplexFairLaunch",
    "8bvPnYE5Pvz2Z9dE6RAqWr1rzLknTndZ9hwvRE6kPDXP",
  );
  return gpaBuilder(context, programId)
    .registerFields<{
      discriminator: Array<number>;
      deployment: PublicKey;
      creatorFeeTreasury: PublicKey;
      creatorFeePerMintLamports: number | bigint;
      transferFeeInBasisPoints: number;
      cosignerProgramId: PublicKey;
      multiplierLimits: OptionOrNullable<MultiplierLimitsArgs>;
      transferFeeWithdrawAuthority: OptionOrNullable<PublicKey>;
      transferFeeTargetWallet: OptionOrNullable<PublicKey>;
      totalSplEquivalentMinted: number | bigint;
      splExcessInEscrow: number | bigint;
      allowBurn: boolean;
      allowClaimTransferFeeAuthAsCreator: boolean;
      uncheckedFungible: boolean;
    }>({
      discriminator: [0, array(u8(), { size: 8 })],
      deployment: [8, publicKeySerializer()],
      creatorFeeTreasury: [40, publicKeySerializer()],
      creatorFeePerMintLamports: [72, u64()],
      transferFeeInBasisPoints: [80, u16()],
      cosignerProgramId: [82, publicKeySerializer()],
      multiplierLimits: [114, option(getMultiplierLimitsSerializer())],
      transferFeeWithdrawAuthority: [null, option(publicKeySerializer())],
      transferFeeTargetWallet: [null, option(publicKeySerializer())],
      totalSplEquivalentMinted: [null, u64()],
      splExcessInEscrow: [null, u64()],
      allowBurn: [null, bool()],
      allowClaimTransferFeeAuthAsCreator: [null, bool()],
      uncheckedFungible: [null, bool()],
    })
    .deserializeUsing<DeploymentConfig>((account) =>
      deserializeDeploymentConfig(account),
    )
    .whereField("discriminator", [13, 112, 57, 81, 43, 26, 156, 18]);
}
